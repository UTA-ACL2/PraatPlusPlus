<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <link href="{{ URL_PREFIX + url_for('static', filename='css/viewer.css') }}" rel="stylesheet" type="text/css"/>
    <link href="{{ URL_PREFIX + url_for('static', filename='css/general.css') }}" rel="stylesheet" type="text/css"/>
    <link href="{{ URL_PREFIX + url_for('static', filename='css/annotation.css') }}" rel="stylesheet" type="text/css"/>
    <link href="{{ URL_PREFIX + url_for('static', filename='css/category.css') }}" rel="stylesheet" type="text/css"/>
    <title>Praat++ Workspace</title>
</head>
<body class="bg-color0">
<div class="container">
    <div id="autoSaveMessage" style="position: fixed; top: 10px; right: 20px; color: red; font-size: 16px; display: none; transition: opacity 2s ease-in-out;">
        auto save: <span id="autoSaveTime">----</span>
    </div>
    <div class="container-fluid" style="text-align: center">
        <div style="display: flex">
            <div style="flex: 1; min-width: 150px; text-align: left;">
                <p><strong>User:</strong> {{ userName }}</p>
                <p style="word-break: break-all;"><strong>File:</strong> {{ fileName }}</p>
                <p><strong>Tiers:</strong> <span id="tierCount">0</span></p>
                <p><strong>Total Annotations:</strong> <span id="annotationCount">0</span></p>
            </div>
            <div style="display: flex; flex-direction: column; margin-left: 20px; gap: 10px;">
                <a href="{{ URL_PREFIX + url_for('login.logout') }}" class="btn btn-primary">Logout</a>
                <a href="{{ URL_PREFIX + url_for('login.general_form') }}" class="btn btn-primary">Back</a>
            </div>
            <!-- Right-side video display area -->
            <div style="flex: 2;">
                <video id="videoPlayer" width="480" height="270" controls>
                    <source id="videoSource" src="{{ videoFile }}" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            </div>
        </div>
        <div id="waveform-container" style="position: relative;">
            <div id="waveform-label" style="  position: absolute;
        top: 70px;
        left: 25px;
        transform: translate(-50%, -50%);
        padding: 5px 5px;
        background-color: white;
        color: black;
        border: 1px solid red;
        font-size: 14px;
        font-weight: bold;
        text-align: center;">Waveform</div>
            <div id="waveform-yaxis" style="
    position: absolute;
    left: 55px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    height: 130px;
    font-size: 15px;
    color: black;
">
                <div id="waveform-y-max">1</div>
                <div>0</div>
                <div id="waveform-y-min">-1</div>
            </div>
            <div id="spectrogram-label" style="  position: absolute;
        top: 200px;
        left: 18px;
        transform: translate(-50%, -50%);
        padding: 5px 5px;
        background-color: white;
        color: black;
        border: 1px solid red;
        font-size: 14px;
        font-weight: bold;
        text-align: center;">Spectrogram</div>
            <div id="spectrogram-yaxis" style="
    position: absolute;
    top: 127px;
    left: 67px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    height: 135px;
    font-size: 13px;
    color: blue;
">
                <div id="spectrogram-y-max">5kHz</div>
                {#                <div>4k Hz</div>#}
                <div id="spectrogram-y-mid">3kHz</div>
                {#                <div>2k Hz</div>#}
                <div id="spectrogram-y-min">0kHz</div>
            </div>
            <div id="waveform" ></div>
        </div>
        <div id="drawings-container" style="position: relative;">
            <div id="drawings-label" style="  position: absolute;
        top: 50%;
        left: 25px;
        transform: translate(-50%, -50%);
        padding: 8px 0px;
        background-color: white;
        color: black;
        border: 1px solid red;
        font-size: 14px;
        font-weight: bold;
        text-align: center; width: 77px; white-space: normal;">Pitch & Intensity</div>
            <div id="drawings" class="arial medium-font">
                <svg id="axis"></svg>
                <div id="chart"></div>
            </div>
        </div>

        <p class="row">
        <div class="col-xs-1">
            <i class="glyphicon glyphicon-zoom-out icon-large" ></i>
        </div>
        <div class="col-xs-10">
            <input id="slider" type="range" min="50" max="80000" value="50" style="width: 100%" disabled />
        </div>
        <div class="col-xs-1">
            <i class="glyphicon glyphicon-zoom-in icon-large" ></i>
        </div>

        <div id="tier-container">
            <div id="name-container" style="display: flex; width: 100px">
            </div>
            <div id="tier-control" style="width: 100%; overflow: hidden; position: relative;">
            </div>
        </div>
        <div id="video-menu" class="context-menu">
            <ul>
                {#                <li data-size="1280x720">Large (1280x720)</li>#}
                {#                <li data-size="1024x576">Medium (1024x576)</li>#}
                <li data-size="800x450">Small (800x450)</li>
                <li data-size="640x360">Extra Small (640x360)</li>
                <li data-size="480x270">Tiny (480x270)</li>
            </ul>
        </div>
        <div id="context-menu" class="context-menu">
            <ul>
                <li id="menu0">Option</li>
                <li id="menu1">Option</li>
                <li id="menu2">Option</li>
                <li id="menu3">Option</li>
                <li id="menu4" class="show-tiers-button">Show Tiers</li>
                <li id="menu5">Delete Tier</li>
                <li id="menu6">Spectrogram Setting</li>
            </ul>
        </div>
        <div id="annotation-menu" class="context-menu">
            <ul class="Emotion-menu">
                <li class="header">Emotion</li>
                <li><label><input type="checkbox" value="happy"> Happy</label></li>
                <li><label><input type="checkbox" value="excited"> Excited</label></li>
                <li><label><input type="checkbox" value="angry"> Angry</label></li>
                <li><label><input type="checkbox" value="anxious"> Anxious</label></li>
                <li><label><input type="checkbox" value="neutral"> Neutral</label></li>
                <li><label><input type="checkbox" value="sad"> Sad</label></li>
            </ul>
            <ul class="Behavior-menu">
                <li class="header">Behavior</li>
                <li><label><input type="checkbox" value="alerting"> Alerting</label></li>
                <li><label><input type="checkbox" value="greeting"> Greeting</label></li>
                <li><label><input type="checkbox" value="playful"> Playful</label></li>
                <li><label><input type="checkbox" value="requesting"> Requesting</label></li>
                <li><label><input type="checkbox" value="defensive"> Defensive</label></li>
                <li><label><input type="checkbox" value="aggressive"> Aggressive</label></li>
                <li><label><input type="checkbox" value="attention-seeking"> Seeking Attention</label></li>
            </ul>
            <div class ="category-btn" style="display: flex;
  justify-content: space-between;
  gap: 8px; padding: 0 8px;">
                <button class="okButton">OK</button>
                <button class="deleteButton">Delete</button>
            </div>
        </div>
        <div id="tier-submenu" class="context-submenu" style="display: none;"></div>

        <div class="col-xs-6">
            <button id="add-tier" class="btn btn-textgrid btn-lg">+ Add Tier</button>
        </div>
        <!-- Dialog box for selecting Tier type -->
        <div id="tierTypeDialog" class="overlay">
            <div class="dialog">
                <h3>Tier Type</h3>
                <button class="tier-type" data-type="interval">Interval Tier</button>
                <button class="tier-type" data-type="point" disabled>Point Tier</button>
                <button id="closeTierDialog">Cancel</button>
            </div>
        </div>
        <!-- Dialog box for selecting annotation category (Interval Tier only) -->
        <div id="categoryDialog" class="overlay">
            <div class="dialog">
                <h3>Annotation Category</h3>
                <div id="categoryList">
                    <button class="annotation-category" data-category="Emotion"><span class="category-text">Emotion</span></button>
                    <button class="annotation-category" data-category="Behavior"><span class="category-text">Behavior</span></button>
                </div>
                <button id="addCategoryButton">Add</button>
                <button id="closeCategoryDialog">Cancel</button>
            </div>
        </div>

        <div id="deleteConfirmDialog" class="overlay" style="display: none;">
            <div class="dialog">
                <h3>Confirm Deletion</h3>
                <p id="deleteCategoryDialogText"></p>
                <div>
                    <button id="confirmDeleteCategory">Delete</button>
                    <button id="cancelDeleteCategory">Cancel</button>
                </div>
            </div>
        </div>

        <div id="deleteTierConfirmDialog" class="overlay" style="display: none;">
            <div class="dialog">
                <h3>Confirm Deletion</h3>
                <p id="deleteTierDialogText"></p>
                <div>
                    <button id="confirmDeleteTier">Delete</button>
                    <button id="cancelDeleteTier">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Form for adding a new Category -->
        <div id="newCategoryDialog" class="overlay" style="display: none;">
            <div class="dialog">
                <h3>Add New Category</h3>
                <label for="newCategoryInput">Category Name:</label>
                <input type="text" id="newCategoryInput" placeholder="Enter category name">
                <h4>Checkbox Attributes</h4>
                <div id="checkboxContainer">
                    <div class="checkbox-item">
                        <input type="text" class="checkbox-input" placeholder="Enter checkbox value">
                        <button class="add-checkbox">➕</button>
                        <button class="remove-checkbox">➖</button>
                    </div>
                </div>
                <button id="saveNewCategory">Save</button>
                <button id="cancelNewCategory">Cancel</button>
            </div>
        </div>
        <div class="col-xs-6 text-right" style="width: 40%; justify-content: space-between;" >
            <button id="downloadTextGrid" class="btn btn-textgrid btn-lg">Export</button>
        </div>

        <div id="spectrogramDialog" class="overlay" style="display: none;">
            <div class="dialog">
                <h3>Spectrogram Settings</h3>
                <label for="specMinHz">Frequency Min (Hz):</label>
                <input type="number" id="specMinHz" placeholder="e.g. 0">
                <label for="specMaxHz">Frequency Max (Hz):</label>
                <input type="number" id="specMaxHz" placeholder="e.g. 5000">
                <button id="saveSpectrogram">Save</button>
                <button id="cancelSpectrogram">Cancel</button>
            </div>
        </div>

    </div>
</div>
<script src="//d3js.org/d3.v3.js"></script>
<script type="module">

    {#import WaveSurfer from 'https://unpkg.com/wavesurfer.js@7.10.1/dist/wavesurfer.esm.js'#}
    {#import Spectrogram from 'https://unpkg.com/wavesurfer.js@7.10.1/dist/plugins/spectrogram.esm.js'#}
    {#import TimelinePlugin from 'https://unpkg.com/wavesurfer.js@7.10.1/dist/plugins/timeline.esm.js'#}
    {#import RegionsPlugin from 'https://unpkg.com/wavesurfer.js@7.10.1/dist/plugins/regions.esm.js'#}
    {#import ZoomPlugin from 'https://unpkg.com/wavesurfer.js@7.10.1/dist/plugins/zoom.esm.js'#}
    {#import Hover from 'https://unpkg.com/wavesurfer.js@7.10.1/dist/plugins/hover.esm.js'#}
    import Spectrowindow from 'https://unpkg.com/wavesurfer.js@7.10.1/dist/plugins/spectrogram-windowed.esm.js'

    import WaveSurfer from "{{ URL_PREFIX + url_for('static', filename='js/wavesurfer.esm.js') }}"
    import Spectrogram from "{{ URL_PREFIX + url_for('static', filename='js/spectrogram.esm.js') }}"
    import spectrogram_emu from "{{ URL_PREFIX }}/static/js/spectrogram_emu.esm.js";
    import TimelinePlugin from "{{ URL_PREFIX + url_for('static', filename='js/timeline.esm.js') }}"
    import RegionsPlugin from "{{ URL_PREFIX + url_for('static', filename='js/regions.esm.js') }}"
    import ZoomPlugin from "{{ URL_PREFIX + url_for('static', filename='js/zoom.esm.js') }}"
    import Hover from "{{ URL_PREFIX + url_for('static', filename='js/hover.esm.js') }}"

    var timeline;
    var videoDuration;
    let selectedTier = null;
    let selectedAnotation = null;
    let addAnnotation;
    let currentZoom;
    let pxPerSec;

    var margin, width, height;
    var parseTime
    var x, y0, y1;
    var xAxis, yAxisLeft, yAxisRight;
    var valueline, valueline2;
    var svg;

    const regions = RegionsPlugin.create()

    // Create a timeline plugin instance with custom options
    const topTimeline = TimelinePlugin.create({
        height: 20,
        insertPosition: 'beforebegin',
        {#timeInterval: 0.1,#}
        {#primaryLabelInterval: 5,#}
        {#primaryLabelSpacing: 1,#}
        {#secondaryLabelInterval: 1,#}
        {#secondaryLabelSpacing: 1,#}
        formatTimeCallback: (seconds) => {
            return seconds.toFixed(3) + "s";  // example：0.12345s
        },
        style: {
            fontSize: '14px',
            color: '#2D5B88',
        },
    })

    // Create a second timeline
    const bottomTimeline = TimelinePlugin.create({
        height: 10,
        timeInterval: 0.1,
        primaryLabelInterval: 1,
        style: {
            fontSize: '10px',
            color: '#6A3274',
        },
    })

    const zoomPlugin = ZoomPlugin.create({
        scale: 0.5,      // the amount of zoom per wheel step, e.g. 0.5 means a 50% magnification per scroll
        maxZoom: 80000,
        exponentialZooming: true
    })

    const hover = Hover.create({
        lineColor: '#ff0000',
        lineWidth: 2,
        labelBackground: 'rgba(0,0,0,0.5)',
        labelColor: '#fff',
        labelSize: '11px',
        formatTimeCallback: (seconds) => {
            return seconds.toFixed(5) + "s";  // example：0.12345s
        },
        getStats: (time) => {
            const { pitch, intensity } = samplePIAt(time);
            return {
                amplitude: ampAtTime_left(time),
                pitch,
                intensity
            };
        }
    })

    const spectrogramPlugin = spectrogram_emu.create({
        height: 128,
    });

    const SpectrowindowPlugin = Spectrowindow.create({
        height: 130,
        fftSamples: 256,
        scale: 'linear',
        frequencyMax: 5000,
        frequencyMin: 0,
        colorMap: 'gray',
        {#labels: true,#}
        labelsBackground: 'rgba(0, 0, 0, 0.1)',
        splitChannels: false,
        useWebWorker: true,
    })

    var wavesurfer = WaveSurfer.create({
        normalize: true,
        autoScroll: false,
        fillParent: false,
        container: '#waveform',
        waveColor: 'rgb(200, 0, 200)',
        progressColor: 'rgb(100, 0, 100)',
        media: document.querySelector('video'),
        sampleRate: 15000,
        minPxPerSec: 100,
        plugins: [
            topTimeline,
            {#bottomTimeline,#}
            regions,
            zoomPlugin,
            hover,
            {#spectrogramPlugin,#}
            SpectrowindowPlugin
        ],
    });

    let isintervalSelecting = false
    const container = document.querySelector(`${wavesurfer.options.container} > div`);
    container.style.backgroundColor = "white";

    var videoPlayer = document.getElementById('videoPlayer');

    window.addEventListener('DOMContentLoaded', () => {
        const observer = new IntersectionObserver(async (entries) => {
            // Detect transition from >=0.5 ➜ <0.5 (entered hidden zone)
            if (entries[0].intersectionRatio < 0.5) {
                await videoPlayer.requestPictureInPicture();
            }
            // Detect transition from <0.5 ➜ >=0.5 (back to viewport)
            if (entries[0].intersectionRatio >= 0.5 ) {
                await document.exitPictureInPicture();
            }
        }, {
            threshold: [0, 0.5, 1.0]
        });
        observer.observe(videoPlayer);
    });

    regions.on('region-clicked', (region, event) => {
        event.stopPropagation(); // Prevent event bubbling
        const start = region.start;
        const end = region.end;
        videoPlayer.currentTime = start;
        region.play()
        const checkEndTime = () => {
            if (videoPlayer.currentTime >= end) {
                videoPlayer.pause();
                return;
            }
            requestAnimationFrame(checkEndTime); // Continuous high-frequency checking
        };
        requestAnimationFrame(checkEndTime);
    });

    wavesurfer.on('interaction', () => {
        regions.clearRegions()
        {#const spectrogramDiv = wavesurfer.getWrapper().parentElement.nextElementSibling;#}
        const pitchDiv = document.getElementById('chart');
        [ pitchDiv].forEach(c => c?.querySelectorAll('.region-overlay')?.forEach(e => e.remove()));
    })

    regions.enableDragSelection({
        color: 'rgba(255, 0, 0, 0.1)',
    })

    regions.on('region-created', (region) => {
        regions.getRegions().forEach(existingRegion => {
            if (existingRegion.id !== region.id) {
                existingRegion.remove(); // Remove other regions
            }
        });
        if(selectedTier && selectedTier.dataset.category && !isintervalSelecting){
            const data = {type: 'interval', start: region.start, end: region.end, id: region.id};
            {#console.log('data',data)#}
            addAnnotation(selectedTier, data);
        } else if (!selectedTier) {
            alert('Select Tier！');
        } else if (!selectedTier.dataset.category) {
            alert('Specify Tier Category！');
        }
        isintervalSelecting = false;
        closeAllMenus();
        selectedAnotation = region.id
        region.element.title = `Start: ${region.start.toFixed(5)}s,\nEnd: ${region.end.toFixed(5)}s,\nDuration: ${(region.end - region.start).toFixed(5)}s`;
        const div = document.getElementById(selectedAnotation)
        const oldMenu  = document.getElementById("annotation-menu")
        const newMenu = oldMenu.cloneNode(true);
        // Replace annotationMenu (remove old event listeners)
        oldMenu .replaceWith(newMenu);
        const annotationMenu = newMenu;
        region.element.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            event.stopPropagation();
            closeAllMenus();
            const selectedValues = div.dataset.text ? div.dataset.text.split(', ').map(val => val.trim()) : [];
            annotationMenu.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = selectedValues.includes(checkbox.value);
            });
            // Select the part to be displayed according to category
            annotationMenu.querySelectorAll('ul').forEach(ul => ul.style.display = 'none'); // Hide all category first
            const safeCategoryName = `${selectedTier.dataset.category.trim() // Remove leading and trailing spaces
                .replace(/^\d+/, "n$&") // If it starts with digits, prefix them with "n"
                .replace(/\s+/g, "-") // Replace all spaces with "-"
                .replace(/[^a-zA-Z0-9-_]/g, "")}`; // Remove any characters except letters, numbers, "-" and "_"
            annotationMenu.querySelector(`.${safeCategoryName}-menu`).style.display = "block";
            // Set menu location
            let menuX = event.clientX;
            let menuY = event.clientY;
            annotationMenu.style.display = 'block'; // First let the menu display and get its height
            let menuHeight = annotationMenu.offsetHeight;
            let menuWidth = annotationMenu.offsetWidth;
            // Calculate whether it exceeds the bottom of the screen
            if (menuY + menuHeight > window.innerHeight) {
                menuY = window.innerHeight - menuHeight - 10; // Float the menu upwards, leaving a 10px gap
            }
            // Calculate whether it exceeds the right side of the screen
            if (menuX + menuWidth > window.innerWidth) {
                menuX = window.innerWidth - menuWidth - 10; // Move the menu to the left, leaving a 10px gap
            }
            annotationMenu.style.left = `${menuX}px`;
            annotationMenu.style.top = `${menuY}px`;
        });
        document.addEventListener('click', (event) => {
            if (!annotationMenu.contains(event.target) && !event.target.classList.contains('okButton')) {
                annotationMenu.style.display = 'none'; // Close menu
            }
        });
        document.addEventListener("scroll", () => {
            annotationMenu.style.display = 'none';
        });
        // Get the order of menu options
        const menuOptions = Array.from(annotationMenu.querySelectorAll('input[type="checkbox"]')).map(
            (checkbox) => checkbox.value
        );
        annotationMenu.querySelectorAll('.okButton').forEach(okButton => {
            okButton.addEventListener('click', (event) => {
                event.stopPropagation();
                {#console.log("OK clicked, confirming selection...");#}
                annotationMenu.style.display = 'none';
            });
        });
        annotationMenu.querySelectorAll("li").forEach(li => {
            li.addEventListener("click", (e) => {
                const checkbox = li.querySelector('input[type="checkbox"]');
                if (!checkbox) return;
                if (e.target === checkbox) return;
                checkbox.checked = !checkbox.checked;
                checkbox.dispatchEvent(new Event("change", { bubbles: true }));
                e.preventDefault();
            });
        });
        annotationMenu.addEventListener('change', (event) => {
            if (event.target.type === 'checkbox') {
                const value = event.target.value;
                const checked = event.target.checked;
                {#console.log(` Value: ${value}, Checked: ${checked}`);#}
                // Initialize or update div.dataset.text
                const currentValues = div.dataset.text ? div.dataset.text.split(', ') : [];
                // Update the value based on the check state of the checkbox
                if (checked) {
                    // If selected, add value
                    if (!currentValues.includes(value)) {
                        currentValues.push(value);
                    }
                } else {
                    // If unchecked, remove the value
                    const index = currentValues.indexOf(value);
                    if (index > -1) {
                        currentValues.splice(index, 1);
                    }
                }
                // Sort by menu order currentValues
                currentValues.sort((a, b) => menuOptions.indexOf(a) - menuOptions.indexOf(b));
                // Update div.dataset.text and set it to a comma-delimited string
                div.dataset.text = currentValues.join(', ');
                div.title = currentValues.join(', ');
                div.setAttribute('data-text', currentValues.join(', ')); // For front-end display
                regions.getRegions()[0].setOptions({ content: currentValues.join(', ') });
            }
        });
        annotationMenu.querySelectorAll('.deleteButton').forEach(okButton => {
            okButton.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent bubbling and click OK from triggering the body's click event
                {#console.log("Delete clicked, confirming delete...");#}
                annotationMenu.style.display = 'none'; // Click OK to hide the menu
                selectedTier.removeChild(div);
                regions.clearRegions();
                {#const spectrogramDiv = wavesurfer.getWrapper().parentElement.nextElementSibling;#}
                const pitchDiv = document.getElementById('chart');
                [ pitchDiv].forEach(c => c?.querySelectorAll('.region-overlay')?.forEach(e => e.remove()));
                countTiersAndAnnotations()
            });
        });

        //  Add synchronized Region to spectrogram and pitch layers
        const createOverlay = (container, region) => {
            Array.from(container.querySelectorAll('.region-overlay')).forEach(e => e.remove());
            const duration = wavesurfer.getDuration();
            const startX = (region.start / duration) * wavesurfer.getWrapper().scrollWidth - wavesurfer.getScroll();
            const width = ((region.end - region.start) / duration) * wavesurfer.getWrapper().scrollWidth;
            const overlay = document.createElement('div');
            overlay.className = 'region-overlay';
            overlay.style.position = 'absolute';
            overlay.style.left = `${startX}px`;
            overlay.style.width = `${width}px`;
            overlay.style.top = '0';
            overlay.style.bottom = '0';
            overlay.style.backgroundColor = region.color;
            overlay.style.pointerEvents = 'none';
            overlay.style.zIndex = '1';
            // Set an ID to facilitate subsequent deletion or synchronous update
            overlay.dataset.regionId = region.id;
            container.appendChild(overlay);
        };
        // Get two containers
        {#const spectrogramDiv = wavesurfer.getWrapper().parentElement.nextElementSibling;#}
        const pitchDiv = document.getElementById('chart');
        // Create two overlays
        {#if (spectrogramDiv) createOverlay(spectrogramDiv, region);#}
        if (pitchDiv) createOverlay(pitchDiv, region);

    })

    regions.on('region-update', (region) => {
        videoPlayer.currentTime = region.start
        region.element.title = `Start: ${region.start.toFixed(5)}s,\nEnd: ${region.end.toFixed(5)}s,\nDuration: ${(region.end - region.start).toFixed(5)}s`;
        // Find the corresponding annotation block
        const annotation = selectedTier.querySelector(`.interval[id="${region.id}"]`);
        if (annotation) {
            // Calculate new styles
            const startPercentage = (region.start / wavesurfer.getDuration()) * 100;
            const widthPercentage = ((region.end - region.start) / wavesurfer.getDuration()) * 100;
            // Update the annotation style
            annotation.style.left = `${startPercentage}%`;
            annotation.style.width = `${widthPercentage}%`;
            // Update the annotation data
            annotation.dataset.start = region.start.toFixed(5);
            annotation.dataset.end = region.end.toFixed(5);
        }
        updateAllRegionOverlays()
    });

    const downloadTextGridButton = document.querySelector('#downloadTextGrid')
    downloadTextGridButton.onclick = ()=>{
        downloadTextGrid()
    }

    let leftPeaks = [];
    let peaksPerSec = 0;
    wavesurfer.on('ready', function () {
        videoDuration = wavesurfer.getDuration();
        var totalPixels = $("#waveform").innerWidth() - 140;
        pxPerSec = totalPixels / videoDuration;
        wavesurfer.zoom(pxPerSec);
        currentZoom = pxPerSec
        setGraphParams(totalPixels);
        initializeGraph();
        $('#slider').attr("min", pxPerSec);
        $('#slider').val(pxPerSec);
        const peaks = wavesurfer.exportPeaks()
        const allPeaks = peaks.flat()
        leftPeaks = peaks[0];                     // Only use channel 0 (left channel) from the audio data
        peaksPerSec = leftPeaks.length / wavesurfer.getDuration();
        {#console.log('peaks',peaks)#}

        const max = Math.max(...allPeaks.map(Math.abs)) || 1
        document.getElementById('waveform-y-max').textContent = max.toFixed(3)
        document.getElementById('waveform-y-min').textContent = (-max).toFixed(3)
    });

    function ampAtTime_left(tSec) {
        if (!leftPeaks.length) return 0;
        const i = Math.max(
            0,
            Math.min(leftPeaks.length - 1, Math.round(tSec * peaksPerSec))
        );
        return leftPeaks[i];
    }

    function updatePlayLine1() {
        var timeRatio = videoPlayer.currentTime / wavesurfer.getDuration();
        var xPosition = timeRatio * width;
        d3.select("#play-line")
            .attr("x1", xPosition)
            .attr("x2", xPosition);
    }

    function updatePlayLine2() {
        const tiers = document.querySelectorAll("#tier-control > div"); // Get all tier containers
        tiers.forEach(tier => {
            const tierWidth = tier.offsetWidth;
            const linePosition = (videoPlayer.currentTime / videoDuration) * tierWidth;
            // Make sure the vertical line is within the tier container
            if (linePosition >= 0 && linePosition <= tierWidth) {
                let playLine = tier.querySelector(".play-line2"); // Find the vertical line in the current container
                if (playLine) {
                    playLine.style.left = `${linePosition}px`; // Update location
                } else {
                    // If there is no vertical line, create a new one
                    playLine = document.createElement("div");
                    playLine.classList.add("play-line2");
                    playLine.style.position = "absolute";
                    playLine.style.top = "0";
                    playLine.style.bottom = "0";
                    playLine.style.width = "1px";
                    playLine.style.backgroundColor = "black";
                    playLine.style.left = `${linePosition}px`;
                    tier.style.position = "relative"; // Make sure the parent container is relatively positioned
                    tier.appendChild(playLine);
                }
            }
        });
    }

    function updateAllRegionOverlays() {
        const regionsList = regions.getRegions();
        const duration = wavesurfer.getDuration();
        {#const spectrogramDiv = wavesurfer.getWrapper().parentElement.nextElementSibling;#}
        const pitchDiv = document.getElementById('chart');
        const containers = [ pitchDiv];
        const scrollLeft = wavesurfer.getScroll();
        const scrollWidth = wavesurfer.getWrapper().scrollWidth;
        regionsList.forEach(region => {
            containers.forEach(container => {
                if (!container) return;
                const overlay = container.querySelector(`.region-overlay[data-region-id="${region.id}"]`);
                if (overlay) {
                    const startX = (region.start / duration) * scrollWidth - scrollLeft;
                    const width = ((region.end - region.start) / duration) * scrollWidth;
                    overlay.style.left = `${startX}px`;
                    overlay.style.width = `${width}px`;
                }
            });
        });
    }



    // Listen for mouse wheel events to achieve zooming
    {#document.getElementById('drawings').addEventListener('wheel', function(event) {#}
    {#    event.preventDefault();#}
    {#    let newZoom = event.deltaY < 0 ? currentZoom + 500 : currentZoom - 500; // Scroll wheel up to zoom in, scroll wheel down to zoom out#}
    {#    newZoom = Math.max(pxPerSec, Math.min(80000, newZoom)); // Limit zoom range#}
    {#    wavesurfer.zoom(newZoom);#}
    {#    $('#slider').val(newZoom);#}
    {#    zoom(soundSeconds * newZoom);#}
    {#    currentZoom = newZoom;#}
    {#    updatePlayLine1();#}
    {#    updatePlayLine2();#}
    {#});#}

    wavesurfer.on('zoom', function (pxPerSec) {
        $(".interval-tier, .point-tier").css("width", (videoDuration * pxPerSec) + "px");
        $('#slider').val(pxPerSec)
        zoom(videoDuration * pxPerSec)
        currentZoom = pxPerSec
        updatePlayLine1();
        updatePlayLine2();
        if (pxPerSec > 1000) {
            wavesurfer.setOptions({ autoScroll: false });
        } else {
            wavesurfer.setOptions({ autoScroll: true });
        }
        updateAllRegionOverlays();
    });

    wavesurfer.on('scroll', (visibleStart, visibleEnd, scrollLeft, scrollRight) => {
        $("#lines").css("left", -scrollLeft);
        $(".interval-tier, .point-tier").css("left", -scrollLeft);
        updateAllRegionOverlays();
    });

    var slider = document.querySelector('#slider');
    {#slider.oninput = function () {#}
    {#    var zoomLevel = Number(slider.value);#}
    {#    currentZoom = zoomLevel#}
    {#    wavesurfer.zoom(zoomLevel);#}
    {#    zoom(soundSeconds * zoomLevel);#}
    {#    updatePlayLine1();#}
    {#    updatePlayLine2();#}
    {#};#}

    {#const zoomInBtn = document.querySelector(".glyphicon-zoom-in");#}
    {#const zoomOutBtn = document.querySelector(".glyphicon-zoom-out");#}
    {##}
    {#zoomInBtn.addEventListener("click", () => {#}
    {#    const newValue = Number(slider.value) + 800;#}
    {#    currentZoom = newValue#}
    {#    wavesurfer.zoom(newValue);#}
    {#    zoom(soundSeconds * newValue);#}
    {#    updatePlayLine1();#}
    {#    updatePlayLine2();#}
    {#});#}
    {##}
    {#zoomOutBtn.addEventListener("click", () => {#}
    {#    const newValue = Number(slider.value) - 800;#}
    {#    if (newValue>pxPerSec) {#}
    {#        currentZoom = newValue#}
    {#        wavesurfer.zoom(newValue);#}
    {#        zoom(soundSeconds * newValue);#}
    {#        updatePlayLine1();#}
    {#        updatePlayLine2();#}
    {#    }#}
    {#});#}

    videoPlayer.addEventListener('seeked', () => {
        if (slider.value > 1000) {
            const wrapper = wavesurfer.getWrapper();
            const totalWidth = wrapper.scrollWidth;
            const visibleDuration = wavesurfer.getDuration() * (wavesurfer.getWidth()  / totalWidth); // Calculate visible time width
            const centerTime = videoPlayer.currentTime - visibleDuration / 2;
            wavesurfer.setScrollTime(centerTime);
        }
    });
    videoPlayer.addEventListener('pause', () => {
        if (slider.value > 1000) {
            const wrapper = wavesurfer.getWrapper();
            const totalWidth = wrapper.scrollWidth;
            const visibleDuration = wavesurfer.getDuration() * (wavesurfer.getWidth() / totalWidth);
            const centerTime = videoPlayer.currentTime - visibleDuration / 2;
            wavesurfer.setScrollTime(centerTime);
        }
    });

    function setGraphParams(newWidth) {
        margin = {top: 20, right: 40, bottom: 30, left: 100},
            width = newWidth /*- margin.left - margin.right*/,
            height = 158 /*- margin.top*/ - margin.bottom;

        parseTime = d3.time.format("%S.%L").parse;

        x = d3.time.scale().range([0, width]);
        y0 = d3.scale.linear().range([height, 0]);
        y1 = d3.scale.linear().range([height, 0]);

        xAxis = d3.svg.axis().scale(x)
            .orient("bottom").ticks(d3.time.seconds, 1)
            .tickFormat(d3.time.format("%M:%S"));

        yAxisLeft = d3.svg.axis().scale(y0)
            .orient("left").ticks(2);

        yAxisRight = d3.svg.axis().scale(y1)
            .orient("right").ticks(2);

        valueline = d3.svg.line()
            .interpolate("basis")
            .defined(function (d) {
                return d.pitch != null && d.pitch != undefined && !isNaN(d.pitch);
            })
            .x(function (d) {
                return x(d.time);
            })
            .y(function (d) {
                return y0(d.pitch);
            });

        valueline2 = d3.svg.line()
            .interpolate("basis")
            .defined(function (d) {
                return d.intensity != null && d.intensity != undefined && !isNaN(d.intensity);
            })
            .x(function (d) {
                return x(d.time);
            })
            .y(function (d) {
                return y1(d.intensity);
            });

        svg = d3.select("#chart").append("svg")
            .attr("width", width /*+ margin.left + margin.right*/)
            .attr("height", height /*+ margin.top*/ + margin.bottom)
            .attr("id", "lines")
            .attr("class", "bg-colorWhite")
            .append("g");
    }

    let graphData = null;
    let bisectTime = d3.bisector(d => d.time).left;
    function initializeGraph() {
        d3.tsv("{{ graphData }}", function (error, data)  {
            if (error) throw error;

            data.forEach(function (d) {
                d.time = parseFloat(d.time) * 1000;
                d.pitch = +d.pitch;
                d.intensity = +d.intensity;
            });

            graphData = data;
            x.domain(d3.extent(data, function (d) {
                return d.time;
            }));
            y0.domain([Math.min(d3.min(data, function (d) {
                return Math.min(d.pitch);
            }), 75), Math.max(d3.max(data, function (d) {
                return Math.max(d.pitch);
            }), 500)]);
            y1.domain([Math.min(d3.min(data, function (d) {
                return Math.min(d.intensity);
            }), 50), Math.max(d3.max(data, function (d) {
                return Math.max(d.intensity);
            }), 100)]);

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis);

            d3.select("#axis").append("g")
                .attr("class", "y axis a-left fill-color2")
                .call(yAxisLeft)
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Hz");

            d3.select("#axis").append("g")
                .attr("class", "y axis a-right fill-color3")
                .attr("transform", "translate(" + width + " ,0)")
                .call(yAxisRight)
                .append("text")
                .attr("transform", "rotate(90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .text("dB");

            svg.append("path")
                .datum(data)
                .attr("class", "line2 color3")
                .attr("d", valueline2);

            svg.append("path")
                .datum(data)
                .attr("class", "line1 color2")
                .attr("d", valueline);
        });

        svg.append("line")
            .attr("id", "play-line")
            .attr("x1", 0)
            .attr("x2", 0)
            .attr("y1", 0)
            .attr("y2", height)
            .attr("stroke", "black")
            .attr("stroke-width", 0.8);
    }

    function samplePIAt(timeSec) {
        if (!graphData || graphData.length === 0) return { pitch: null, intensity: null };

        const t = timeSec * 1000;
        let i = bisectTime(graphData, t);
        if (i <= 0)   return { pitch: graphData[0].pitch, intensity: graphData[0].intensity };
        if (i >= graphData.length) {
            const last = graphData[graphData.length - 1];
            return { pitch: last.pitch, intensity: last.intensity };
        }

        const a = graphData[i - 1], b = graphData[i];
        const k = (t - a.time) / (b.time - a.time);
        const lerp = (x, y) => x + (y - x) * k;

        return {
            pitch: lerp(a.pitch, b.pitch),
            intensity: lerp(a.intensity, b.intensity)
        };
    }
    {#wavesurfer.on('timeupdate', (t) => {#}
    {#    const { pitch, intensity } = samplePIAt(t);#}
    {#});#}

    // Waveform synchronization, update the position of the vertical line
    wavesurfer.on('timeupdate', function (currentTime) {
        updatePlayLine1();
        updatePlayLine2();
    });

    function zoom(value) {
        $("svg").attr("width", value + "px");
        width = value;
        x = d3.time.scale().range([0, width]);

        $(".y.axis.a-right").attr("transform", "translate(" + Math.min($("#lines").outerWidth(), $("#chart").outerWidth()) + " ,0)");

        d3.tsv("{{ graphData }}", function (error, data)  {
            var svg = d3.select("#drawings").transition();

            data.forEach(function (d) {
                d.time = parseFloat(d.time) * 1000;
                d.pitch = +d.pitch;
                d.intensity = +d.intensity;
            });

            x.domain(d3.extent(data, function (d) {
                return d.time;
            }));

            xAxis = d3.svg.axis().scale(x)
                .orient("bottom").ticks(getSmartTickCount(x))
                .tickFormat(generateTickFormat());

            svg.select(".line1")
                .duration(0)
                .attr("d", valueline(data));

            svg.select(".line2")
                .duration(0)
                .attr("d", valueline2(data));

            svg.select(".x.axis") // change the x axis
                .duration(0)
                .call(xAxis);
        });
    }

    function generateTickFormat() {
        return function (d) {
            {#console.log('Number(slider.value)',Number(slider.value))#}
            if (Number(slider.value) < 100) {
                return (d / 1000).toFixed(0) + "s";
            } else {
                return (d / 1000).toFixed(1) + "s";
            }
        };
    }

    function getSmartTickCount(xScale) {
        const domain = xScale.domain();
        const duration = domain[1] - domain[0];  // millisecond
        const maxTickDensity = 100; // One tick every 100ms = 0.1s
        const maxTicks = Math.floor(duration / maxTickDensity);  // Maximum number of ticks
        const defaultTickCount = Math.floor(width / 50);  // original logic
        return Math.min(defaultTickCount, maxTicks);  // No more than maxTicks
    }

    // Highlight logic
    wavesurfer.on('audioprocess', () => {
        const currentTime = wavesurfer.getCurrentTime();
        // Highlight Interval
        document.querySelectorAll('.interval').forEach(interval => {
            const start = parseFloat(interval.dataset.start);
            const end = parseFloat(interval.dataset.end);
            if (currentTime >= start && currentTime <= end) {
                interval.style.backgroundColor = "rgba(255, 165, 0, 0.6)"; // Highlight orange
            } else {
                interval.style.backgroundColor = "rgba(173, 216, 230, 0.6)";
            }
        });
        // Highlight Point
        document.querySelectorAll('.point').forEach(point => {
            const time = parseFloat(point.dataset.time);
            if (Math.abs(currentTime - time) < 0.1) {
                point.style.backgroundColor = "rgba(255, 0, 0, 0.6)"; // Highlight red
            } else {
                point.style.backgroundColor = "rgba(144, 238, 144, 0.6)";
            }
        });
    });

    // Collect annotation
    const collectAnnotations = () => {
        const tiers = Array.from(document.querySelectorAll("#tier-control > div")); // Get all tiers
        const annotations = [];

        tiers.forEach(tier => {
            const tierType = tier.classList.contains("interval-tier") ? "interval" : "point";
            const tierId = tier.id;
            const tierInput = document.getElementById(`${tierId}name`);
            const tierName = tierInput?.value || tierId; // Use the input box value or the default ID as the name
            const category = tier.dataset.category || "default";

            if (tierType === "interval") {
                const intervalAnnotations = Array.from(tier.getElementsByClassName("interval")).map(interval => ({
                    xmin: parseFloat(interval.dataset.start),
                    xmax: parseFloat(interval.dataset.end),
                    text: interval.dataset.text || ""
                })).filter(item => !isNaN(item.xmin) && !isNaN(item.xmax) && item.xmin < item.xmax);
                intervalAnnotations.sort((a, b) => a.xmin - b.xmin);
                annotations.push({
                    type: "IntervalTier",
                    category: category,
                    name: tierName,
                    data: intervalAnnotations
                });
            } else if (tierType === "point") {
                const pointAnnotations = Array.from(tier.getElementsByClassName("point")).map(point => ({
                    number: parseFloat(point.dataset.time),
                    mark: point.dataset.text || ""
                }));
                pointAnnotations.sort((a, b) => a.number - b.number);
                annotations.push({
                    type: "TextTier",
                    name: tierName,
                    data: pointAnnotations
                });
            }
        });
        return annotations;
    };

    // Generate TextGrid file content
    const generateTextGridContent = (annotations, videoDuration) => {
        let content = `File type = "ooTextFile"\nObject class = "TextGrid"\n\n`;
        content += `xmin = 0\nxmax = ${videoDuration}\ntiers? <exists>\nsize = ${annotations.length}\nitem []:\n`;

        annotations.forEach((tier, index) => {
            content += `    item [${index + 1}]:\n        class = "${tier.type}"\n        name = "${tier.name}"\n`;
            content += `        xmin = 0\n        xmax = ${videoDuration}\n`;

            if (tier.type === "IntervalTier") {
                content += `        intervals: size = ${tier.data.length}\n`;
                tier.data.forEach((interval, idx) => {
                    content += `        intervals [${idx + 1}]:\n            xmin = ${interval.xmin}\n`;
                    content += `            xmax = ${interval.xmax}\n            text = "${interval.text}"\n`;
                });
            } else if (tier.type === "TextTier") {
                content += `        points: size = ${tier.data.length}\n`;
                tier.data.forEach((point, idx) => {
                    content += `        points [${idx + 1}]:\n            number = ${point.number}\n`;
                    content += `            mark = "${point.mark}"\n`;
                });
            }
        });
        return content;
    };
    const fileName = "{{ fileName }}";
    // File download logic
    function downloadTextGrid() {
        const annotations = collectAnnotations();
        const textGridContent = generateTextGridContent(annotations, videoDuration);
        const blob = new Blob([textGridContent], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${fileName}.TextGrid`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    document.addEventListener("DOMContentLoaded", () => {
        const nameContainer = document.getElementById("name-container")
        const tierContainer = document.getElementById("tier-control");
        // Bind the function of Tier click event
        const bindTierClickEvent = (tier, tierType) => {
            let clickTimeout;
            tier.addEventListener("click", (event) => {
                selectedTier = tier;
                if (event.target.classList.contains("handle-left") || event.target.classList.contains("handle-right")) {
                    // Get the parent element interval
                    const intervalElement = event.target.parentElement;
                    if (intervalElement && intervalElement.classList.contains("interval")) {
                        // Get the interval's dataset.start
                        const start = parseFloat(intervalElement.dataset.start);
                        const end = parseFloat(intervalElement.dataset.end);
                        videoPlayer.currentTime = start; // Jump to the start time of the interval
                        // Reset the background color of all intervals to the default blue
                        document.querySelectorAll(".interval").forEach((interval) => {
                            interval.style.backgroundColor = "rgba(173, 216, 230, 0.6)"; // blue
                        });
                        // Set the currently clicked interval to orange
                        intervalElement.style.backgroundColor = "rgba(255, 165, 0, 0.6)"; // orange

                        selectedAnotation = intervalElement.id;
                        isintervalSelecting = true;
                        regions.clearRegions()
                        regions.addRegion({
                            id: selectedAnotation,
                            content: intervalElement.title,
                            start: start,
                            end: end, // Initially, start and end are the same.
                            color: 'rgba(0, 123, 255, 0.5)'
                        });
                    }
                    return; // Return directly to avoid executing the new annotation logic
                }
                // If you click on a "point" or "interval", jump directly to the corresponding time
                if (event.target.classList.contains("point") || event.target.classList.contains("interval")) {
                    // Reset the background color of all intervals to the default blue
                    document.querySelectorAll(".interval").forEach((interval) => {
                        interval.style.backgroundColor = "rgba(173, 216, 230, 0.6)"; // blue
                    });
                    // Set the currently clicked interval to orange
                    event.target.style.backgroundColor = "rgba(255, 165, 0, 0.6)"; // orange
                    if (event.target.classList.contains("point")) {
                        const time = parseFloat(event.target.dataset.time);
                        videoPlayer.currentTime = time; // Jump to the corresponding time point
                        {#console.log(`Point clicked, jumping to time: ${time}`);#}
                    } else if (event.target.classList.contains("interval")) {
                        // Handle click event logic for "interval"
                        const start = parseFloat(event.target.dataset.start);
                        const end = parseFloat(event.target.dataset.end);

                        selectedAnotation = event.target.id;
                        isintervalSelecting = true;
                        regions.clearRegions()
                        regions.addRegion({
                            id: selectedAnotation,
                            content: event.target.title,
                            start: start,
                            end: end, // Initially, start and end are the same.
                            color: 'rgba(0, 123, 255, 0.5)'
                        });
                        // Jump to the start time and start playing
                        videoPlayer.currentTime = start;
                    }
                    return; // Return directly to avoid executing the new annotation logic
                }
                clearTimeout(clickTimeout); // Clear the effects of double-click
            });
        };

        // add annotation function
        addAnnotation = (tier, data) => {
            const div = document.createElement("div");
            if (data.type === "interval") {
                div.className = "interval";
                div.id = data.id; // Link the region ID
                div.title = data.text ? data.text : "";
                div.dataset.start = data.start.toFixed(5);
                div.dataset.end = data.end.toFixed(5);
                div.dataset.text = data.text ? data.text : "";
                const startPercentage = Math.max(0, Math.min((data.start / videoDuration) * 100, 100));
                const widthPercentage = Math.max(0, Math.min(((data.end - data.start) / videoDuration) * 100, 100));
                div.style.left = startPercentage + "%";
                div.style.width = widthPercentage + "%";

                const handleLeft = document.createElement('div');
                handleLeft.className = 'handle handle-left';
                const handleRight = document.createElement('div');
                handleRight.className = 'handle handle-right';
            } else if (data.type === "point") {
                div.className = "point";
                div.dataset.time = data.time.toFixed(5);
                const timePercentage = Math.max(0, Math.min((data.time / videoDuration) * 100, 100));
                div.style.left = timePercentage + "%";
            }
            tier.appendChild(div);
            countTiersAndAnnotations();

            const annotationMenu = document.getElementById("annotation-menu").cloneNode(true);
            document.body.appendChild(annotationMenu); // Add to page
            div.addEventListener('contextmenu', (event) => {
                event.stopPropagation(); // Prevent event bubbling and triggering the contextmenu event of the parent element
                event.preventDefault(); // Block default right-click menu
                closeAllMenus();
                document.querySelectorAll('.interval-tier').forEach(t => t.classList.remove('selected'));
                document.querySelectorAll('.point-tier').forEach(t => t.classList.remove('selected'));
                tier.classList.add('selected');
                selectedTier = tier; // Get the selected tier ID
                const start = parseFloat(event.target.dataset.start);
                const end = parseFloat(event.target.dataset.end);
                selectedAnotation = event.target.id;
                isintervalSelecting = true;
                regions.clearRegions()
                regions.addRegion({
                    id: selectedAnotation,
                    content: event.target.title,
                    start: start,
                    end: end, // Initially, start and end are the same.
                    color: 'rgba(0, 123, 255, 0.5)',
                });
                videoPlayer.currentTime = start;
                document.querySelectorAll(".interval").forEach((interval) => {
                    interval.style.backgroundColor = "rgba(173, 216, 230, 0.6)"; // blue
                });
                div.style.backgroundColor = "rgba(255, 165, 0, 0.6)"; // orange
                const selectedValues = div.dataset.text ? div.dataset.text.split(', ').map(val => val.trim()) : [];
                annotationMenu.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = selectedValues.includes(checkbox.value);
                });
                // Select the part to be displayed according to category
                annotationMenu.querySelectorAll('ul').forEach(ul => ul.style.display = 'none'); // Hide all categories first

                const safeCategoryName = `${tier.dataset.category.trim() // Remove leading and trailing spaces
                    .replace(/^\d+/, "n$&") // If it starts with digits, prefix them with "n"
                    .replace(/\s+/g, "-") // Replace all spaces with "-"
                    .replace(/[^a-zA-Z0-9-_]/g, "")}`; // Remove any characters except letters, numbers, "-" and "_"
                annotationMenu.querySelector(`.${safeCategoryName}-menu`).style.display = "block";
                // Set menu location
                let menuX = event.clientX;
                let menuY = event.clientY;
                annotationMenu.style.display = 'block'; // First let the menu display and get its height
                let menuHeight = annotationMenu.offsetHeight;
                let menuWidth = annotationMenu.offsetWidth;
                // Calculate whether it exceeds the bottom of the screen
                if (menuY + menuHeight > window.innerHeight) {
                    menuY = window.innerHeight - menuHeight - 10; // Float the menu upwards, leaving a 10px gap
                }
                // Calculate whether it exceeds the right side of the screen
                if (menuX + menuWidth > window.innerWidth) {
                    menuX = window.innerWidth - menuWidth - 10; // Move the menu to the left, leaving a 10px gap
                }
                annotationMenu.style.left = `${menuX}px`;
                annotationMenu.style.top = `${menuY}px`;
            });
            document.addEventListener('click', (event) => {
                if (!annotationMenu.contains(event.target) && !event.target.classList.contains('okButton')) {
                    annotationMenu.style.display = 'none'; // Close menu
                }
            });
            document.addEventListener("scroll", () => {
                annotationMenu.style.display = 'none';
            });
            // Get the menu option order
            const menuOptions = Array.from(annotationMenu.querySelectorAll('input[type="checkbox"]')).map(
                (checkbox) => checkbox.value
            );
            annotationMenu.querySelectorAll('.okButton').forEach(okButton => {
                okButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    {#console.log("OK clicked, confirming selection...");#}
                    annotationMenu.style.display = 'none';
                });
            });
            annotationMenu.querySelectorAll("li").forEach(li => {
                li.addEventListener("click", (e) => {
                    const checkbox = li.querySelector('input[type="checkbox"]');
                    if (!checkbox) return;
                    if (e.target === checkbox) return;
                    checkbox.checked = !checkbox.checked;
                    checkbox.dispatchEvent(new Event("change", { bubbles: true }));
                    e.preventDefault();
                });
            });
            // Listen for the selection state of the checkbox
            annotationMenu.addEventListener('change', (event) => {
                if (event.target.type === 'checkbox') {
                    const value = event.target.value;
                    const checked = event.target.checked;
                    {#console.log(` Value: ${value}, Checked: ${checked}`);#}
                    // Initialize or update div.dataset.text
                    const currentValues = div.dataset.text ? div.dataset.text.split(', ') : [];
                    // Update the value based on the check state of the checkbox
                    if (checked) {
                        // If selected, add value
                        if (!currentValues.includes(value)) {
                            currentValues.push(value);
                        }
                    } else {
                        // If unchecked, remove the value
                        const index = currentValues.indexOf(value);
                        if (index > -1) {
                            currentValues.splice(index, 1);
                        }
                    }
                    // Sort by menu order currentValues
                    currentValues.sort((a, b) => menuOptions.indexOf(a) - menuOptions.indexOf(b));
                    // Update div.dataset.text and set it to a comma-delimited string
                    div.dataset.text = currentValues.join(', ');
                    div.title = currentValues.join(', ');
                    div.setAttribute('data-text', currentValues.join(', ')); // For front-end display
                    regions.getRegions()[0].setOptions({ content: currentValues.join(', ') });
                }
            });
            annotationMenu.querySelectorAll('.deleteButton').forEach(okButton => {
                okButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    {#console.log("Delete clicked, confirming delete...");#}
                    annotationMenu.style.display = 'none';
                    tier.removeChild(div);
                    regions.clearRegions();
                    {#const spectrogramDiv = wavesurfer.getWrapper().parentElement.nextElementSibling;#}
                    const pitchDiv = document.getElementById('chart');
                    [ pitchDiv].forEach(c => c?.querySelectorAll('.region-overlay')?.forEach(e => e.remove()));
                    countTiersAndAnnotations()
                });
            });
        };

        document.getElementById("add-tier").addEventListener("click", () => {
            document.getElementById("tierTypeDialog").style.display = "flex";
        });

        // Listen for Tier Type Selection
        document.querySelectorAll(".tier-type").forEach(button => {
            button.addEventListener("click", function () {
                let tierType = this.dataset.type;
                if (tierType === "interval") {
                    document.getElementById("tierTypeDialog").style.display = "none"; // Close Tier selection
                    document.getElementById("categoryDialog").style.display = "flex"; // Open Annotation Category and select
                } else {
                    addPointTier()
                    closeAllDialogs();
                }
            });
        });
        // Listen for Annotation Category selection (only for Interval Tier)
        document.addEventListener("click", function (event) {
            if (event.target.closest('.delete-icon')) return;
            const button = event.target.closest('.annotation-category');
            if (button) {
                const category = button.querySelector('.category-text')?.textContent;
                addIntervalTier(category, category);
                closeAllDialogs();
            }
        });

        // Close dialog
        document.getElementById("closeTierDialog").addEventListener("click", closeAllDialogs);
        document.getElementById("closeCategoryDialog").addEventListener("click", closeAllDialogs);

        function closeAllDialogs() {
            document.getElementById("tierTypeDialog").style.display = "none";
            document.getElementById("categoryDialog").style.display = "none";
        }


        const contextMenu = document.getElementById("context-menu");
        const tierSubmenu = document.getElementById("tier-submenu");
        // Add Interval Tier button logic
        function addIntervalTier(Category, TierName) {
            let index = tierContainer.children.length;
            let newTierId;
            // Loop until a non-existing ID is found
            do {
                newTierId = `tier${index + 1}`;
                index++;
            } while (document.getElementById(newTierId));
            const newTier = document.createElement("div");
            newTier.style.width = (videoDuration * currentZoom) + "px";
            newTier.style.left = -wavesurfer.getScroll() + 'px';
            newTier.id = newTierId;
            newTier.className = "interval-tier"; // Added as interval-tier
            newTier.dataset.category = Category
            addTierNames(newTier); // Add a name for each tier
            tierContainer.appendChild(newTier);
            countTiersAndAnnotations()
            bindTierClickEvent(newTier, "interval"); // Bind click event
            const tierInput = document.getElementById(`${newTier.id}name`);
            tierInput.setAttribute('title', Category); // set title
            tierInput.setAttribute('value', TierName);
            document.querySelectorAll('.interval-tier').forEach(t => t.classList.remove('selected'));
            document.querySelectorAll('.point-tier').forEach(t => t.classList.remove('selected'));
            newTier.classList.add('selected');
            selectedTier = newTier;
            newTier.addEventListener('click', () => {
                // Clear the previous selection
                document.querySelectorAll('.interval-tier').forEach(t => t.classList.remove('selected'));
                document.querySelectorAll('.point-tier').forEach(t => t.classList.remove('selected'));
                // Set the current tier to selected
                newTier.classList.add('selected');
                selectedTier = newTier; // Get the selected tier ID
            });
            newTier.addEventListener("contextmenu", (event) => {
                event.preventDefault();
                event.stopPropagation();
                closeAllMenus();
                let menuX = event.clientX;
                let menuY = event.clientY;
                contextMenu.style.display = 'block';
                let menuWidth = contextMenu.offsetWidth;
                let menuHeight = contextMenu.offsetHeight;
                if (menuX + menuWidth > window.innerWidth) {
                    menuX = window.innerWidth - menuWidth - 10; // Leave a 10px gap
                }
                if (menuY + menuHeight > window.innerHeight) {
                    menuY = window.innerHeight - menuHeight - 10; // Leave a 10px gap
                }
                contextMenu.style.top = `${menuY}px`;
                contextMenu.style.left = `${menuX}px`;
                contextMenu.style.display = "block";
                document.querySelectorAll('.interval-tier').forEach(t => t.classList.remove('selected'));
                document.querySelectorAll('.point-tier').forEach(t => t.classList.remove('selected'));
                newTier.classList.add('selected');
                selectedTier = newTier;
                menu0.style.display = "none";
                menu1.style.display = "none";
                menu2.style.display = "none";
                menu3.style.display = "block";
                menu3.textContent = "Hide This Tier";
                menu4.style.display = "block";
                menu5.style.display = "block";
                menu6.style.display = "none";
                updateTierSubmenu();
            });
            return newTier;
        };
        window.addIntervalTier = addIntervalTier;

        // Adding Point Tier button logic
        function addPointTier() {
            const existingTiers = tierContainer.children.length;
            const newTierId = `tier${existingTiers + 1}`; // The ID of the new tier
            const newTier = document.createElement("div");
            newTier.style.width = (videoDuration * currentZoom) + "px";
            newTier.id = newTierId;
            newTier.className = "point-tier"; // Add as point-tier
            addTierNames(newTier, existingTiers); // Add a name for each tier
            tierContainer.appendChild(newTier);
            bindTierClickEvent(newTier, "point"); // Bind click event
            newTier.addEventListener("contextmenu", (event) => {
                event.preventDefault();
                event.stopPropagation();
                closeAllMenus();
                contextMenu.style.top = `${event.clientY}px`;
                contextMenu.style.left = `${event.clientX}px`;
                contextMenu.style.display = "block";
                selectedTier = newTier
                menu0.style.display = "none";
                menu1.style.display = "none";
                menu2.style.display = "none";
                menu3.style.display = "block"; // Show Tier Menu
                menu3.textContent = "Hide This Tier";
                updateTierSubmenu();
            });
            return newTier;
        };
        window.addPointTier = addPointTier;
        // Update submenu content
        function updateTierSubmenu() {
            const tiers = document.querySelectorAll(".interval-tier, .point-tier"); // Get all tiers
            tierSubmenu.innerHTML = ""; // Clear submenu
            tiers.forEach((tier) => {
                if (tier.style.display === "none") {
                    const tierId = tier.id;
                    // Get the name corresponding to the tier
                    const tierInput = document.getElementById(`${tierId}name`); // Assume the input box's ID is "tier1-name"
                    const tierName = tierInput?.value || tierId;
                    const tierOption = document.createElement("div");
                    tierOption.textContent = `Show ${tierName}`; // Show name or ID
                    tierOption.className = "tier-option";
                    tierOption.addEventListener("click", () => {
                        tierInput.style.display = "block";
                        tier.style.display = "block"; // Show Tier
                        tierSubmenu.style.display = "none";
                        contextMenu.style.display = "none";
                    });
                    tierSubmenu.appendChild(tierOption);
                }
            });
            if (tierSubmenu.innerHTML === "") {
                const emptyMessage = document.createElement("div");
                emptyMessage.textContent = "No hidden tiers";
                emptyMessage.className = "tier-option disabled";
                tierSubmenu.appendChild(emptyMessage);
            }
        }

        menu3.addEventListener("click", () => {
            if (selectedTier) {
                const tierId = selectedTier.id; // Get the tier ID
                const tierNameInput = document.getElementById(`${tierId}name`); // Get the corresponding tierName input box
                // Hide Tier and corresponding Name
                selectedTier.style.display = "none";
                tierNameInput.style.display = "none"; // Hide input box
                contextMenu.style.display = "none"; // Hide menu
                updateTierSubmenu();
            }
        });

        menu5.addEventListener("click", () => {
            if (selectedTier) {
                const tierNameInput = document.getElementById(`${selectedTier.id}name`);
                document.getElementById('deleteTierDialogText').innerHTML = `Are you sure you want to delete <strong>"${tierNameInput.value}"</strong>?`
                document.getElementById('deleteTierConfirmDialog').style.display = 'flex';
                contextMenu.style.display = "none";
            }
        });

        document.getElementById('confirmDeleteTier').addEventListener('click', function() {
            const tierId = selectedTier.id;  // Get the tier ID
            const tierNameInput = document.getElementById(`${tierId}name`); // Get the corresponding input box
            // Remove the Tier and the corresponding Name
            selectedTier.remove();
            selectedTier = null;
            if (tierNameInput) tierNameInput.remove();
            regions.clearRegions();
            const pitchDiv = document.getElementById('chart');
            [ pitchDiv].forEach(c => c?.querySelectorAll('.region-overlay')?.forEach(e => e.remove()));
            contextMenu.style.display = "none";
            document.getElementById('deleteTierConfirmDialog').style.display = 'none';
            countTiersAndAnnotations()
        });

        document.getElementById('cancelDeleteTier').addEventListener('click', function(){
            document.getElementById('deleteTierConfirmDialog').style.display = 'none';
        });

        function addTierNames(tier, index) {
            let nameContainer = document.getElementById("name-container");
            // Left input box
            const input = document.createElement("input");
            input.type = "text";
            input.className = "name-input";
            input.id = `${tier.id}name`; // Bind unique ID
            input.placeholder = `${tier.id}`;
            input.title = "";
            nameContainer.appendChild(input);

            input.addEventListener("contextmenu", (event) => {
                event.preventDefault();
                event.stopPropagation();
                closeAllMenus();
                let menuX = event.clientX;
                let menuY = event.clientY;
                contextMenu.style.display = 'block';
                let menuWidth = contextMenu.offsetWidth;
                let menuHeight = contextMenu.offsetHeight;
                if (menuX + menuWidth > window.innerWidth) {
                    menuX = window.innerWidth - menuWidth - 10; // Leave a 10px gap
                }
                if (menuY + menuHeight > window.innerHeight) {
                    menuY = window.innerHeight - menuHeight - 10; // Leave a 10px gap
                }
                contextMenu.style.top = `${menuY}px`;
                contextMenu.style.left = `${menuX}px`;
                contextMenu.style.display = "block";
                selectedTier = tier; // Save the current right-click Tier
                menu0.style.display = "none";
                menu1.style.display = "none";
                menu2.style.display = "none";
                menu3.style.display = "block";
                menu3.textContent = "Hide This Tier";
                menu4.style.display = "block";
                menu5.style.display = "block";
                menu6.style.display = "none";
                updateTierSubmenu();
            })
        }

        // Logic for the Tier delete button
        document.getElementById("remove-tier").addEventListener("click", () => {
            const existingTiers = tierContainer.children.length;
            if (existingTiers > 0) {
                nameContainer.removeChild(nameContainer.lastElementChild);
                tierContainer.removeChild(tierContainer.lastElementChild);
            } else {
                alert("No Tier!");
            }
        });

        // Initialize Tier click event binding
        const tiers = Array.from(tierContainer.children);
        tiers.forEach((tier) => {
            const isIntervalTier = tier.classList.contains("interval-tier");
            const tierType = isIntervalTier ? "interval" : "point";
            bindTierClickEvent(tier, tierType);
        });
    });

    function enableDragAndResize(tier) {
        // Add drag logic
        tier.addEventListener('mousedown', (event) => {
            let target = event.target;
            // If the clicked element is a handle, get the parent element
            if (target.classList.contains('handle-left') || target.classList.contains('handle-right')) {
                target = target.parentElement;
            }
            // Determine whether the parent element is interval or point
            if (target.classList.contains('interval') || target.classList.contains('point')) {
                const isInterval = target.classList.contains('interval');
                const startX = event.clientX;
                const tierWidth = tier.offsetWidth;
                // Get the initial width and position
                const startWidthPercentage = isInterval
                    ? (target.offsetWidth / tierWidth) * 100
                    : 0;
                const startLeftPercentage = isInterval
                    ? (target.offsetLeft / tierWidth) * 100
                    : parseFloat(target.style.left || '0');
                const onMouseMove = (moveEvent) => {
                    const dx = moveEvent.clientX - startX;
                    const dxPercentage = (dx / tierWidth) * 100;
                    if (isInterval) {
                        if (target.dataset.resizing === 'left') {
                            const newLeftPercentage = Math.max(0, startLeftPercentage + dxPercentage);
                            const newWidthPercentage = Math.max(1, startWidthPercentage - dxPercentage);
                            target.style.left = `${newLeftPercentage}%`;
                            target.style.width = `${newWidthPercentage}%`;
                            target.dataset.start = ((newLeftPercentage / 100) * videoDuration).toFixed(2);
                            target.dataset.end = (((newLeftPercentage + newWidthPercentage) / 100) * videoDuration).toFixed(2);
                        } else if (target.dataset.resizing === 'right') {
                            const newWidthPercentage = Math.max(1, startWidthPercentage + dxPercentage);
                            target.style.width = `${newWidthPercentage}%`;
                            target.dataset.end = (((startLeftPercentage + newWidthPercentage) / 100) * videoDuration).toFixed(2);
                        } else {
                            const newLeftPercentage = Math.min(
                                100 - startWidthPercentage,
                                Math.max(0, startLeftPercentage + dxPercentage)
                            );
                            target.style.left = `${newLeftPercentage}%`;
                            target.dataset.start = ((newLeftPercentage / 100) * videoDuration).toFixed(2);
                            target.dataset.end = (((newLeftPercentage + startWidthPercentage) / 100) * videoDuration).toFixed(2);
                        }
                    } else {
                        const newLeftPercentage = Math.max(0, Math.min(100, startLeftPercentage + dxPercentage));
                        target.style.left = `${newLeftPercentage}%`;
                        target.dataset.time = ((newLeftPercentage / 100) * videoDuration).toFixed(2);
                    }
                };
                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    delete target.dataset.resizing;
                };
                // Determine whether the left handle or the right handle is clicked
                if (event.target.classList.contains('handle-left')) {
                    target.dataset.resizing = 'left';
                } else if (event.target.classList.contains('handle-right')) {
                    target.dataset.resizing = 'right';
                }
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }
        });
    };

    function countTiersAndAnnotations() {
        // Count the number of tiers
        const tiers = document.querySelectorAll("#tier-control .interval-tier");
        const tierCount = tiers.length;
        // Count the number of annotations
        const annotations = document.querySelectorAll("#tier-control .interval-tier .interval");
        const annotationCount = annotations.length;
        document.getElementById("tierCount").textContent = tierCount;
        document.getElementById("annotationCount").textContent = annotationCount;
    }

    function closeAllMenus() {
        const menus = document.querySelectorAll(".context-menu"); // Select all possible top-level menus
        menus.forEach((menu) => {
            menu.style.display = "none";
        });
    }

    document.addEventListener("DOMContentLoaded", () => {
        const contextMenu = document.getElementById("context-menu");
        const waveformlabel = document.querySelector("#waveform-label");
        const spectrogramlabel = document.querySelector("#spectrogram-label");
        const spectrogramyaxis = document.querySelector("#spectrogram-yaxis")
        const drawingslabel = document.querySelector("#drawings-label");
        const waveform = document.querySelector("#waveform");
        const canvasesDiv = wavesurfer.getWrapper().querySelector('.canvases'); //waveform
        {#const spectrogramDiv = wavesurfer.getWrapper().parentElement.nextElementSibling#}
        {#hover.attachToContainer(spectrogramDiv);#}
        const drawings = document.querySelector("#drawings");
        hover.attachToContainer(document.querySelector("#chart"));
        const menu0 = document.querySelector("#menu0");
        menu0.textContent = "Hide Waveform";
        const menu1 = document.querySelector("#menu1");
        menu1.textContent = "Hide Spectrogram";
        const menu2 = document.querySelector("#menu2");
        menu2.textContent = "Hide Pitch & Intensity";
        const menu3 = document.querySelector("#menu3"); // Used to hide Tier
        const menu4 = document.querySelector("#menu4"); // Used to show hidden Tiers
        const menu5 = document.querySelector("#menu5"); // Used to delete Tier
        const menu6 = document.querySelector("#menu6");
        const tierSubmenu = document.getElementById("tier-submenu"); // submenu container
        // Bind right-click event
        waveform.addEventListener("contextmenu", (event) => {
            event.preventDefault();
            closeAllMenus();
        });
        waveformlabel.addEventListener("contextmenu", (event) => {
            event.stopPropagation()
            event.preventDefault();
            closeAllMenus();
        });
        {#spectrogramDiv.addEventListener("contextmenu", (event) => {#}
        {#    event.stopPropagation()#}
        {#    event.preventDefault();#}
        {#    closeAllMenus();#}
        {#    contextMenu.style.top = `${event.clientY}px`;#}
        {#    contextMenu.style.left = `${event.clientX}px`;#}
        {#    contextMenu.style.display = "block";#}
        {#    menu0.style.display = "none";#}
        {#    menu1.style.display = "block";#}
        {#    menu2.style.display = "none";#}
        {#    menu3.style.display = "none";#}
        {#    menu4.style.display = "none";#}
        {#    menu5.style.display = "none";#}
        {#    updateTierSubmenu();#}
        {#});#}
        spectrogramlabel.addEventListener("contextmenu", (event) => {
            event.stopPropagation()
            event.preventDefault();
            closeAllMenus();
            contextMenu.style.top = `${event.clientY}px`;
            contextMenu.style.left = `${event.clientX}px`;
            contextMenu.style.display = "block";
            menu0.style.display = "none";
            menu1.style.display = "none";
            menu2.style.display = "none";
            menu3.style.display = "none";
            menu4.style.display = "none";
            menu5.style.display = "none";
            menu6.style.display = "block";
            updateTierSubmenu();
        });
        drawings.addEventListener("contextmenu", (event) => {
            event.preventDefault();
            closeAllMenus();
            // Display menu and set position
            contextMenu.style.top = `${event.clientY}px`;
            contextMenu.style.left = `${event.clientX}px`;
            contextMenu.style.display = "block";
            menu0.style.display = "none";
            menu1.style.display = "none";
            menu2.style.display = "block";
            menu3.style.display = "none";
            menu4.style.display = "none";
            menu5.style.display = "none";
            menu6.style.display = "none";
            updateTierSubmenu();
        });
        // Hide menu
        document.addEventListener("click", () => {
            contextMenu.style.display = "none";
            tierSubmenu.style.display = "none";
            videoMenu.style.display = "none";
        });
        document.addEventListener("scroll", () => {
            contextMenu.style.display = "none";
            tierSubmenu.style.display = "none";
            videoMenu.style.display = "none";
        });
        // Menu option click event
        menu0.addEventListener("click", () => {
            if (canvasesDiv.style.display === "none") {
                canvasesDiv.style.display = "block";
                waveformlabel.style.display = "block";
                menu0.textContent = "Hide Waveform";
            } else {
                canvasesDiv.style.display = "none";
                waveformlabel.style.display = "none";
                menu0.textContent = "Show Waveform";
            }
            contextMenu.style.display = "none";
        });
        {#menu1.addEventListener("click", () => {#}
        {#    const plugins = wavesurfer.getActivePlugins();#}
        {#    let hasSpectrogram = false;#}
            {#console.log('wavesurfer.getPlugin',plugins)#}
        {#    for (const plugin of plugins) {#}
        {#        if (plugin instanceof spectrogram_emu) {#}
        {#            spectrogramlabel.style.display = "none";#}
        {#            spectrogramyaxis.style.display = "none";#}
        {#            menu1.textContent = "Show Spectrogram";#}
        {#            hasSpectrogram = true;#}
        {#            plugin.destroy();#}
        {#            wavesurfer.plugins = wavesurfer.plugins.filter(p => p !== plugin);#}
        {#            return;#}
        {#        }#}
        {#    }#}
        {#    if (!hasSpectrogram) {#}
        {#        spectrogramlabel.style.display = "block";#}
        {#        spectrogramyaxis.style.display = "flex";#}
        {#        menu1.textContent = "Hide Spectrogram";#}
        {#        const spectrogramPlugin = spectrogram_emu.create({#}
        {#            height: 128,#}
        {#        });#}
        {#        hover.attachToContainer(spectrogramDiv);#}
        {#        wavesurfer.registerPlugin(spectrogramPlugin);#}
        {#        spectrogramPlugin.render();  // Manually trigger rendering#}
        {#    }#}
        {#});#}
        menu2.addEventListener("click", () => {
            if (drawings.style.display === "none") {
                drawings.style.display = "block";
                drawingslabel.style.display = "block";
                menu2.textContent = "Hide Pitch & Intensity";
            } else {
                drawings.style.display = "none";
                drawingslabel.style.display = "none";
                menu2.textContent = "Show Pitch & Intensity";
            }
            contextMenu.style.display = "none";
        });
        menu4.addEventListener("mouseover", (event) => {
            // Calculate the initial position
            let submenuX = parseFloat(contextMenu.style.left) + contextMenu.offsetWidth;
            let submenuY = event.clientY;
            // Display and get the size
            tierSubmenu.style.display = "block";
            let menuWidth = tierSubmenu.offsetWidth;
            let menuHeight = tierSubmenu.offsetHeight;
            // Prevent overflow on the right side
            if (submenuX + menuWidth > window.innerWidth) {
                submenuX = parseFloat(contextMenu.style.left) - menuWidth;  // Change to left pop-up
            }
            // Prevent overflow at the bottom
            if (submenuY + menuHeight > window.innerHeight) {
                submenuY = window.innerHeight - menuHeight - 10;  // Indent by 10px
            }
            // Apply position
            tierSubmenu.style.left = `${submenuX}px`;
            tierSubmenu.style.top = `${submenuY}px`;
        });
        const M = document.getElementById('spectrogramDialog')
        const specMinInput = document.getElementById('specMinHz')
        const specMaxInput = document.getElementById('specMaxHz')
        menu6.addEventListener("click", () => {
            for (const plugin of wavesurfer.plugins) {
                if ('frequencyMin' in plugin && 'frequencyMax' in plugin) {
                    specMinInput.value = plugin.frequencyMin
                    specMaxInput.value = plugin.frequencyMax
                    break;
                }
            }
            M.style.display = 'flex'
        });
        document.getElementById('cancelSpectrogram').onclick = () => (M.style.display = 'none')
        M.addEventListener('click', (e) => { if (e.target === M) M.style.display = 'none' })
        {#console.log('wavesurfer.plugins_2',wavesurfer.plugins)#}
        document.getElementById('saveSpectrogram').addEventListener('click', () => {
            // Validate inputs
            if (isNaN(Number(specMinInput.value)) || isNaN(Number(specMaxInput.value))) {
                alert("Please enter valid numbers for frequency range!")
                return
            }
            if (Number(specMinInput.value) >= Number(specMaxInput.value)) {
                alert("Minimum frequency must be smaller than maximum frequency!")
                return
            }

            for (const plugin of wavesurfer.plugins) {
                if ('frequencyMin' in plugin && 'frequencyMax' in plugin) {
                    plugin.destroy();
                    wavesurfer.plugins = wavesurfer.plugins.filter(p => p !== plugin);
                    break;
                }
            }
            const SpectrowindowPlugin = Spectrowindow.create({
                height: 130,
                fftSamples: 256,
                scale: 'linear',
                frequencyMax: Number(specMaxInput.value),
                frequencyMin: Number(specMinInput.value),
                colorMap: 'gray',
                {#labels: true,#}
                labelsBackground: 'rgba(0, 0, 0, 0.1)',
                splitChannels: false,
                useWebWorker: true,
            })
            wavesurfer.registerPlugin(SpectrowindowPlugin)
            const minHz = Number(specMinInput.value)
            const maxHz = Number(specMaxInput.value)
            const midHz = (maxHz - minHz) / 2 + minHz
            document.getElementById('spectrogram-y-max').textContent =
                maxHz >= 1000 ? (maxHz / 1000).toFixed(1) + 'kHz' : maxHz + 'Hz'
            document.getElementById('spectrogram-y-mid').textContent =
                midHz >= 1000 ? (midHz / 1000).toFixed(1) + 'kHz' : midHz + 'Hz'
            document.getElementById('spectrogram-y-min').textContent =
                minHz >= 1000 ? (minHz / 1000).toFixed(1) + 'kHz' : minHz + 'Hz'
            M.style.display = 'none'
        })

        function updateTierSubmenu() {
            const tiers = document.querySelectorAll(".interval-tier, .point-tier"); // Get all tiers
            tierSubmenu.innerHTML = ""; // Clear submenu
            tiers.forEach((tier) => {
                if (tier.style.display === "none") {
                    const tierId = tier.id;
                    // Get the name corresponding to the tier
                    const tierInput = document.getElementById(`${tierId}name`); // Assume the input box's ID is "tier1-name"
                    const tierName = tierInput?.value || tierId;
                    const tierOption = document.createElement("div");
                    tierOption.textContent = `Show ${tierName}`; // Show name or ID
                    tierOption.className = "tier-option";
                    tierOption.addEventListener("click", () => {
                        tierInput.style.display = "block";
                        tier.style.display = "block"; // Show Tier
                        tierSubmenu.style.display = "none";
                        contextMenu.style.display = "none";
                    });
                    tierSubmenu.appendChild(tierOption);
                }
            });
            if (tierSubmenu.innerHTML === "") {
                const emptyMessage = document.createElement("div");
                emptyMessage.textContent = "No hidden tiers";
                emptyMessage.className = "tier-option disabled";
                tierSubmenu.appendChild(emptyMessage);
            }
        }

        const videoMenu = document.getElementById('video-menu');
        videoPlayer.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            closeAllMenus();
            videoMenu.style.display = 'block';
            videoMenu.style.left = `${event.clientX}px`;
            videoMenu.style.top = `${event.clientY}px`;
        });
        videoMenu.addEventListener('click', (event) => {
            const target = event.target;
            if (target.tagName === 'LI') {
                const [width, height] = target.dataset.size.split('x');
                videoPlayer.style.width = `${width}px`;
                videoPlayer.style.height = `${height}px`;
                videoMenu.style.display = 'none';
            }
        });

        // Listen for right-click events (limited to blank areas)
        document.addEventListener("contextmenu", function (event) {
            if (!event.target.closest("#waveform, #drawings-container, #videoPlayer")) {
                event.preventDefault();
                closeAllMenus();
                let menuX = event.clientX;
                let menuY = event.clientY;
                contextMenu.style.display = 'block';
                let menuWidth = contextMenu.offsetWidth;
                let menuHeight = contextMenu.offsetHeight;
                if (menuX + menuWidth > window.innerWidth) {
                    menuX = window.innerWidth - menuWidth - 10;
                }
                if (menuY + menuHeight > window.innerHeight) {
                    menuY = window.innerHeight - menuHeight - 10;
                }
                contextMenu.style.left = `${menuX}px`;
                contextMenu.style.top = `${menuY}px`;
                contextMenu.style.display = "block";
                menu0.style.display = "none";
                menu1.style.display = "none";
                menu2.style.display = "block";
                menu3.style.display = "none";
                menu4.style.display = "block";
                menu5.style.display = "none";
                menu6.style.display = "block";
                updateTierSubmenu();
            } else {
                {#contextMenu.style.display = "none";#}
            }
        });
    });

    let currentUsername = "{{ userName }}";
    document.addEventListener("DOMContentLoaded", function () {
        const videoElement = document.querySelector("video");
        if (videoElement) {
            setInterval(autoSaveAnnotations, 120000);
        }
        let currentLockedFile = fileName;
        window.addEventListener("beforeunload", function () {
            autoSaveOnExit();
            if (currentLockedFile) {
                navigator.sendBeacon(
                    "{{ URL_PREFIX }}/unlock_file",
                    new Blob([
                        JSON.stringify({
                            username: currentUsername,
                            filename: currentLockedFile
                        })
                    ], { type: "application/json" })
                );
            }
        });
    });

    wavesurfer.on('ready', function () {
        loadAnnotations()
    });

    function loadAnnotations() {
        fetch(`{{ URL_PREFIX }}/load_annotation?username=${currentUsername}&videoName=${fileName}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    restoreAnnotations(data.annotations);
                } else {
                    console.log("No annotation found for this video.");
                }
            })
            .catch(error => console.error("Error loading annotations:", error));
    }

    function restoreAnnotations(annotationData) {
        // Get the category list on the current page
        const existingCategories = Array.from(document.querySelectorAll("#categoryList .annotation-category"))
            .map(btn => btn.dataset.category);

        annotationData.forEach(tierData => {
            if (!existingCategories.includes(tierData.category)) {
                console.warn("Skip non-existent category:", tierData.category);
                return;
            }
            let tier;  // Store the Tier object
            if (tierData.type === "IntervalTier") {
                tier = addIntervalTier(tierData.category, tierData.name);
            } else if (tierData.type === "TextTier") {
                tier = addPointTier();
            }
            if (!tier) {
                console.error(" Failed to create tier:", tierData);
                return;
            }
            //Traverse tierData.data and add annotation
            tierData.data.forEach((originalData, index) => {
                let data = {}; // Create a data object that conforms to the addAnnotation() structure
                if (tierData.type === "IntervalTier") {
                    data = {
                        type: "interval",
                        start: originalData.xmin,
                        end: originalData.xmax,
                        id: `interval-${tierData.name}-${index}`, // Generate unique ID
                        text: originalData.text,
                    };
                } else if (tierData.type === "TextTier") {
                    data = {
                        type: "point",
                        time: originalData.number,
                        id: `point-${tier.name}-${index}` // Generate unique ID
                    };
                }
                addAnnotation(tier, data);
            });
        });
    }

    function prepareAnnotationPayload() {
        const rawAnnotations = collectAnnotations();
        {#if (!rawAnnotations || !Array.isArray(rawAnnotations) || rawAnnotations.length === 0) return null;#}

        const filtered = JSON.parse(JSON.stringify(
            rawAnnotations
                .filter(item =>
                    item &&
                    typeof item === 'object' &&
                    Array.isArray(item.data)
                )
                .map(item => ({
                    ...item
                    // No longer changes item.data
                }))
        ));

        {#if (filtered.length === 0) return null;#}

        return {
            username: currentUsername,
            videoName: fileName,
            annotations: filtered
        };
    }

    function autoSaveAnnotations() {
        const jsonData = prepareAnnotationPayload();
        if (!jsonData) return;

        fetch(`{{ URL_PREFIX }}/save_annotation`, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(jsonData)
        })
            .then(response => {
                if (!response.ok) throw new Error("Server error");
                return response.json();
            })
            .then(data => {
                console.log("Auto-saved annotation:", data);
            })
            .catch(error => {
                console.error("Error auto-saving annotation:", error);
            });

        // UI prompts
        const autoSaveTime = document.getElementById("autoSaveTime");
        const autoSaveMessage = document.getElementById("autoSaveMessage");
        const now = new Date();
        autoSaveTime.textContent = now.toLocaleTimeString();
        autoSaveMessage.style.display = "block";
        autoSaveMessage.style.opacity = "1";
        setTimeout(() => {
            autoSaveMessage.style.opacity = "0";
            setTimeout(() => {
                autoSaveMessage.style.display = "none";
            }, 2000);
        }, 3000);
    }

    function autoSaveOnExit() {
        const jsonData = prepareAnnotationPayload();
        if (!jsonData) return;
        const blob = new Blob([JSON.stringify(jsonData)], {
            type: 'application/json'
        });
        navigator.sendBeacon(`{{ URL_PREFIX }}/save_annotation`, blob);
    }

    document.addEventListener("DOMContentLoaded", function () {
        const categoryList = document.getElementById("categoryList");
        const addCategoryButton = document.getElementById("addCategoryButton");
        const newCategoryDialog = document.getElementById("newCategoryDialog");
        const saveNewCategoryButton = document.getElementById("saveNewCategory");
        const cancelNewCategoryButton = document.getElementById("cancelNewCategory");
        const checkboxContainer = document.getElementById("checkboxContainer");

        // Load the user's saved Category
        fetch(`{{ URL_PREFIX }}/load_custom_categories?username=${currentUsername}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    data.categories.forEach(category => {
                        addCategoryToUI(category.category, category.options);
                        addCategoryToMenu(category.category, category.options);
                    });
                }
            });

        // Click the Add button to open the add dialog
        addCategoryButton.addEventListener("click", function () {
            newCategoryDialog.style.display = "flex";
        });

        // Cancel add new category
        cancelNewCategoryButton.addEventListener("click", function () {
            newCategoryDialog.style.display = "none";
        });

        // Listen for the "+" button and insert a new Checkbox row below the current row
        document.addEventListener("click", function (event) {
            if (event.target.classList.contains("add-checkbox")) {
                const parentDiv = event.target.parentElement;
                const newCheckbox = createCheckboxItem(); // Create a new checkbox row
                parentDiv.after(newCheckbox); // Insert a new line after the current line
            }
        });

        // Listen for the "-" button and delete the Checkbox row
        document.addEventListener("click", function (event) {
            if (event.target.classList.contains("remove-checkbox")) {
                const parentDiv = event.target.parentElement;
                if (checkboxContainer.children.length > 1) {
                    parentDiv.remove(); // Delete the current line
                }
            }
        });

        // Create a new checkbox input row
        function createCheckboxItem() {
            const newCheckbox = document.createElement("div");
            newCheckbox.classList.add("checkbox-item");

            const input = document.createElement("input");
            input.type = "text";
            input.classList.add("checkbox-input");
            input.placeholder = "Enter checkbox value";

            const addButton = document.createElement("button");
            addButton.textContent = "➕";
            addButton.classList.add("add-checkbox");

            const removeButton = document.createElement("button");
            removeButton.textContent = "➖";
            removeButton.classList.add("remove-checkbox");

            newCheckbox.appendChild(input);
            newCheckbox.appendChild(addButton);
            newCheckbox.appendChild(removeButton);
            return newCheckbox;
        }

        // Save new Category
        saveNewCategoryButton.addEventListener("click", function () {
            const categoryName = document.getElementById("newCategoryInput").value.trim();
            const checkboxes = Array.from(document.querySelectorAll(".checkbox-input"))
                .map(input => input.value.trim())
                .filter(value => value !== "");

            if (categoryName && checkboxes.length > 0) {
                saveNewCategory(categoryName, checkboxes);
            }
        });

        function saveNewCategory(category, options) {
            fetch("{{ URL_PREFIX }}/save_custom_category", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ username: currentUsername, category: category, options: options })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        addCategoryToUI(category, options);
                        addCategoryToMenu(category, options);
                        newCategoryDialog.style.display = "none";
                    }
                });
        }

        function addCategoryToUI(category, options) {
            const newCategorybutton = document.createElement("button");
            newCategorybutton.classList.add("annotation-category");
            // Keep only letters, numbers, "-" and "_"
            newCategorybutton.dataset.category = `${category.trim() // Remove leading and trailing spaces
                .replace(/^\d+/, "n$&") // Add prefix "n" if it starts with a number
                .replace(/\s+/g, "-") // Replace spaces with "-"
                .replace(/[^a-zA-Z0-9-_]/g, "")}`; // Remove all characters except letters, numbers, "-" and "_"
            newCategorybutton.dataset.category = category
            const textSpan = document.createElement("span");
            textSpan.classList.add("category-text");
            textSpan.textContent = category;
            const deleteIcon = document.createElement("span");
            deleteIcon.classList.add("delete-icon");
            deleteIcon.title = "Delete";
            deleteIcon.innerHTML = `
        <svg viewBox="0 0 24 24" width="20" height="20" xmlns="http://www.w3.org/2000/svg">
            <circle cx="12" cy="12" r="10" fill="red"></circle>
            <rect x="7" y="11" width="10" height="2" rx="1" fill="white"></rect>
        </svg>
    `;
            newCategorybutton.appendChild(textSpan);
            newCategorybutton.appendChild(deleteIcon);
            categoryList.appendChild(newCategorybutton);
        }

        function addCategoryToMenu(categoryName, options) {
            const annotationMenu = document.getElementById("annotation-menu");
            // Convert categoryName to comply with CSS rules
            const safeCategoryName = `${categoryName.trim() // Remove leading and trailing spaces
                .replace(/^\d+/, "n$&") // Add prefix "n" if it starts with a number
                .replace(/\s+/g, "-") // Replace spaces with "-"
                .replace(/[^a-zA-Z0-9-_]/g, "")}`; // Remove all characters except letters, numbers, "-" and "_"
            // Check if the category already exists
            if (annotationMenu.querySelector(`.${safeCategoryName}-menu`)) {
                console.warn(`Category '${categoryName}' already exists.`);
                return;
            }

            // Create a new `ul`
            let ul = document.createElement("ul");
            ul.classList.add(`${safeCategoryName}-menu`);
            ul.style.display = "none";

            // Add category title
            let header = document.createElement("li");
            header.classList.add('header');
            header.textContent = categoryName.toUpperCase();
            ul.appendChild(header);

            // Add `checkbox` option
            options.forEach(option => {
                let li = document.createElement("li");
                let label = document.createElement("label");
                let input = document.createElement("input");
                input.type = "checkbox";
                input.value = option;
                label.appendChild(input);
                label.appendChild(document.createTextNode(" " + option));
                li.appendChild(label);
                ul.appendChild(li);
            });
            // Add to `menu-container`
            annotationMenu.insertBefore(ul, annotationMenu.querySelector(".category-btn"))
        }

        let targetCategoryButton = null;
        document.addEventListener("click", function(event) {
            if (event.target.closest('.delete-icon')) {
                event.stopPropagation()
                targetCategoryButton = event.target.closest('.annotation-category');
                const category = targetCategoryButton.querySelector('.category-text')?.textContent;
                // Check if there is a tier
                const hasTier = checkIfHasTier(category);
                const dialogText = document.getElementById('deleteCategoryDialogText');
                if (hasTier) {
                    dialogText.innerHTML = `This category has a corresponding tier. Are you sure you want to delete <strong style="color:red;">"${category}"</strong> and its tier?`;
                } else {
                    dialogText.innerHTML = `Are you sure you want to delete <strong>"${category}"</strong>?`;
                }
                document.getElementById('deleteConfirmDialog').style.display = 'flex';
            }
        });

        // Click to confirm deletion
        document.getElementById('confirmDeleteCategory').addEventListener('click', function() {
            if (targetCategoryButton) {
                const category = targetCategoryButton.querySelector('.category-text')?.textContent;
                // Request backend deletion
                deleteCategoryOnServer(category);
                // Delete frontend
                if (checkIfHasTier(category)) {
                    deleteTier(category);
                }
                targetCategoryButton.remove();
                document.getElementById('deleteConfirmDialog').style.display = 'none';
            }
        });

        document.getElementById('cancelDeleteCategory').addEventListener('click', function(){
            document.getElementById('deleteConfirmDialog').style.display = 'none';
        });

        function deleteCategoryOnServer(category) {
            fetch(`{{ URL_PREFIX }}/delete_custom_category`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ category: category })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.status !== 'success') {
                        alert('Server Error: ' + data.message);
                    }
                });
        }
        function checkIfHasTier(category) {
            return document.querySelector(`.interval-tier[data-category="${category}"]`) !== null;
        }

        function deleteTier(category) {
            document.querySelectorAll(`.interval-tier[data-category="${category}"]`).forEach(tier => tier.remove());
            document.querySelectorAll(`.name-input[title="${category}"]`).forEach(input => input.remove());
        }
    });
</script>
</body>
</html>
